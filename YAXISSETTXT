ChatGPT 4o mini

Log in
You said:
For box plot palette different categories 
ChatGPT said:
ChatGPT
To create a box plot with different categories represented by distinct colors, you can define a custom color palette. The approach varies depending on the programming language and plotting library you're using. Below are examples for common libraries in Python (Matplotlib and Seaborn).

1. Using Seaborn (Python)
Seaborn makes it easy to assign different colors to different categories in a box plot by using the palette argument. You can use predefined palettes or create a custom one.

Example with predefined palette:
import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
tips = sns.load_dataset("tips")

# Create a box plot with different colors for each 'sex' category
sns.boxplot(x="sex", y="total_bill", data=tips, palette="Set2")

plt.show()
Example with custom colors:
import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
tips = sns.load_dataset("tips")

# Custom palette
custom_palette = {"Male": "lightblue", "Female": "lightpink"}

# Create a box plot with custom colors for the 'sex' categories
sns.boxplot(x="sex", y="total_bill", data=tips, palette=custom_palette)

plt.show()
2. Using Matplotlib (Python)
In Matplotlib, you can assign colors manually using the boxprops attribute or by customizing the color of the individual boxes.

Example:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = [np.random.normal(0, 1, 100), np.random.normal(1, 2, 100), np.random.normal(2, 3, 100)]

# Box plot with different colors for each category
plt.boxplot(data, patch_artist=True, 
            boxprops=dict(facecolor='lightblue', color='blue'),
            flierprops=dict(markerfacecolor='red', marker='o'),
            medianprops=dict(color='green'))

plt.show()
Example with different colors for each category:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = [np.random.normal(0, 1, 100), np.random.normal(1, 1.5, 100), np.random.normal(2, 2, 100)]

# Custom colors for each category
colors = ['lightblue', 'lightgreen', 'lightcoral']

# Create a box plot with different colors for each category
plt.boxplot(data, patch_artist=True, 
            boxprops=dict(facecolor=colors[0], color='blue'),
            medianprops=dict(color='black'))

# Modify other categories' colors
for i in range(1, len(data)):
    plt.boxplot(data[i], positions=[i+1], patch_artist=True, 
                boxprops=dict(facecolor=colors[i], color='blue'),
                medianprops=dict(color='black'))

plt.show()
3. Customizing Box Plot Colors in Plotly (Python)
If you're using Plotly, it's very straightforward to customize colors for box plots.

Example:
import plotly.express as px

# Sample data
tips = px.data.tips()

# Create box plot with custom colors for each category
fig = px.box(tips, x="sex", y="total_bill", color="sex", 
             color_discrete_map={"Male": "lightblue", "Female": "lightpink"})

fig.show()
Conclusion:
In Seaborn and Matplotlib, you can easily customize box plot colors by either using predefined palettes or defining custom colors. Plotly allows a similar approach but with more interactive features. Choose the method that best fits your visualization style and the libraries you are using!


You said:
Palette name coolwarm , vidisir
ChatGPT said:
ChatGPT
In Python visualization libraries like Seaborn and Matplotlib, you can use various built-in color palettes such as coolwarm and viridis. These palettes are particularly useful for heatmaps or continuous data, but can also be applied to other types of plots like box plots.

1. Seaborn with coolwarm and viridis Palette
In Seaborn, the coolwarm and viridis color maps are useful for representing continuous data, but you can apply them to categorical data like box plots as well by passing them to the palette argument.

Example: Seaborn with coolwarm Palette
The coolwarm palette is a diverging color map that goes from blue to red, typically used to show deviations from a central value.

import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
tips = sns.load_dataset("tips")

# Create a box plot with the 'coolwarm' color palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="coolwarm")

plt.show()
Example: Seaborn with viridis Palette
The viridis palette is a perceptually uniform color map (going from yellow to purple) that's often used for continuous data but can also be applied to categorical data.

import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
tips = sns.load_dataset("tips")

# Create a box plot with the 'viridis' color palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="viridis")

plt.show()
2. Matplotlib with coolwarm and viridis
Matplotlib provides a range of color maps, and you can use them to color individual elements of a box plot as well.

Example: Matplotlib with coolwarm Palette
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = [np.random.normal(0, 1, 100), np.random.normal(1, 1.5, 100), np.random.normal(2, 2, 100)]

# Create a box plot and apply the 'coolwarm' palette
plt.boxplot(data, patch_artist=True, 
            boxprops=dict(facecolor=plt.cm.coolwarm(0.2), color='blue'),
            medianprops=dict(color='green'))

plt.show()
Example: Matplotlib with viridis Palette
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = [np.random.normal(0, 1, 100), np.random.normal(1, 1.5, 100), np.random.normal(2, 2, 100)]

# Create a box plot and apply the 'viridis' palette
plt.boxplot(data, patch_artist=True, 
            boxprops=dict(facecolor=plt.cm.viridis(0.5), color='blue'),
            medianprops=dict(color='green'))

plt.show()
3. Plotly with coolwarm and viridis
Plotly allows you to easily apply continuous color scales to visualizations, and you can do this with coolwarm and viridis in a similar way.

Example: Plotly with coolwarm Palette
import plotly.express as px

# Sample data
tips = px.data.tips()

# Create box plot with the 'coolwarm' color palette
fig = px.box(tips, x="sex", y="total_bill", color="sex", color_continuous_scale="coolwarm")
fig.show()
Example: Plotly with viridis Palette
import plotly.express as px

# Sample data
tips = px.data.tips()

# Create box plot with the 'viridis' color palette
fig = px.box(tips, x="sex", y="total_bill", color="sex", color_continuous_scale="viridis")
fig.show()
Summary:
coolwarm: A diverging color map from blue to red, often used to show data that diverges around a central value.
viridis: A perceptually uniform color map, going from yellow to purple, that works well for continuous data.
Both of these color maps are often used with continuous data but can also be adapted for categorical data in plots like box plots, especially when you want a visually appealing and meaningful representation of the categories.


You said:
Any other types
ChatGPT said:
ChatGPT
Yes, both Seaborn and Matplotlib offer a wide range of other color palettes and colormaps that can be used for different types of visualizations, including box plots. Here’s a rundown of some commonly used color palettes and colormaps in Seaborn, Matplotlib, and Plotly:

Seaborn Color Palettes
Seaborn has several predefined color palettes, which are often grouped by their purpose or characteristics. You can use these palettes for a variety of plot types, including categorical and continuous visualizations.

1. Categorical Palettes
These palettes are designed for discrete categories, and they often use distinct colors to differentiate between categories.

deep: Default palette, good for general purposes.
muted: A more subdued version of deep.
pastel: Soft pastel colors.
dark: Bold, dark colors.
colorblind: Designed to be distinguishable by people with color vision deficiencies.
Set1, Set2, Set3, Paired, etc.: Predefined sets of colors that can be used for multiple categories.
Example: Using Set1 palette
import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
tips = sns.load_dataset("tips")

# Box plot with Set1 color palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="Set1")

plt.show()
2. Diverging Palettes
These palettes are used for continuous data where the values diverge around a midpoint (e.g., positive/negative, hot/cold).

coolwarm: A diverging palette from blue to red.
BrBG, RdBu, PiYG: Other diverging palettes that range from one color to another.
Example: Using RdBu palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="RdBu")
plt.show()
3. Sequential Palettes
These palettes are used for data that ranges from low to high values. They generally use a single hue that varies in lightness or saturation.

Blues, Greens, Purples, Oranges: Common sequential palettes.
YlGnBu, GnBu, OrRd: Palettes with a specific range of hues.
Example: Using Blues sequential palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="Blues")
plt.show()
4. Cubehelix Palettes
This is a sequential palette designed to be viewed in black-and-white prints, as it avoids saturation and contrast problems in grayscale.

cubehelix: A single-color gradient palette.
Example: Using cubehelix palette
sns.boxplot(x="sex", y="total_bill", data=tips, palette="cubehelix")
plt.show()
Matplotlib Colormaps
Matplotlib offers a range of colormaps designed for continuous data. These colormaps can be used with plt.cm to apply to any plot, including box plots.

1. Perceptually Uniform Colormaps
These colormaps are designed for continuous data and are perceptually uniform, meaning they appear consistent in terms of how the human eye perceives changes in color.

viridis: A widely used perceptually uniform colormap (yellow to purple).
inferno: Ranges from black to yellow to red to white.
plasma: A high-contrast colormap.
cividis: A colormap optimized for color vision deficiency.
Example: Using viridis colormap
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = [np.random.normal(0, 1, 100), np.random.normal(1, 1.5, 100), np.random.normal(2, 2, 100)]

# Box plot with viridis colormap
plt.boxplot(data, patch_artist=True, 
            boxprops=dict(facecolor=plt.cm.viridis(0.5), color='blue'),
            medianprops=dict(color='green'))

plt.show()
2. Sequential Colormaps
These colormaps are used for continuous data that progresses from low to high values.

Blues, Purples, Oranges, YlGnBu, etc.
3. Diverging Colormaps
Diverging colormaps are ideal for data that has a meaningful midpoint (e.g., zero), such as heatmaps or difference maps.

coolwarm: From blue to red, often used for diverging data.
RdBu, Spectral, PiYG, etc.
4. Cyclic Colormaps
These are useful when your data wraps around in a cyclical fashion, like time of day or angle.

twilight, hsv, gist_earth, etc.
Plotly Color Scales
Plotly also provides an array of color scales that you can apply in your visualizations, particularly useful when working with continuous or categorical variables.

1. Diverging Color Scales
coolwarm: Blue to red, with white in the center.
RdBu, PiYG, BrBG: Other diverging scales.
2. Sequential Color Scales
Viridis, Plasma, Inferno: Continuous and perceptually uniform.
Blues, Oranges, Greens: Sequential, low to high.
3. Categorical Color Scales
These scales are often used for discrete categories in a plot.

Set1, Set2, Set3: Discrete categories with distinct colors.
Pastel, Paired, Dark: Other options for categorical data.
Example: Using Viridis color scale in Plotly box plot
import plotly.express as px

# Sample data
tips = px.data.tips()

# Create a box plot with the 'viridis' color scale
fig = px.box(tips, x="sex", y="total_bill", color="sex", color_continuous_scale="viridis")
fig.show()
Summary of Color Palettes and Colormaps
Categorical Palettes (Seaborn):
deep, muted, Set1, colorblind
Diverging Palettes (Seaborn, Matplotlib, Plotly):
coolwarm, RdBu, PiYG
Sequential Palettes (Seaborn, Matplotlib, Plotly):
Blues, Purples, Oranges, Viridis
Perceptually Uniform Colormaps (Matplotlib):
viridis, inferno, plasma
Other Special Palettes:
cubehelix (Seaborn)
twilight (Matplotlib)
These options allow you to adjust the look and feel of your plots, whether you’re working with categorical data, continuous data, or diverging data. You can experiment with different palettes to match your data's purpose and aesthetic preferences!


You said:
viridis: A widely used perceptually uniform colormap (yellow to purple).
inferno: Ranges from black to yellow to red to white.
plasma: A high-contrast colormap.
cividis: I need  rypes
ChatGPT said:
ChatGPT
It seems like you want a detailed breakdown of viridis, inferno, plasma, and cividis, especially focusing on their types or color characteristics. Here's an explanation of each colormap, what kind of data they are suited for, and their visual characteristics:

1. Viridis
Type: Perceptually Uniform
Range: From dark purple (low values) to yellow (high values)
Purpose: Designed for continuous data, it is perceptually uniform, meaning the perceptual difference between values is consistent across the entire range. It is ideal for displaying data where the exact values need to be readable, even in grayscale or when viewed by individuals with color vision deficiencies.
Visual Characteristics:
Starts with dark purple, transitions to blue, green, and finally ends in yellow.
The color changes in a smooth, gradual way, with no abrupt jumps.
Excellent for displaying data over a range of values, where both extremes and middle values need clear differentiation.
Example: Using viridis in Matplotlib:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = np.random.rand(10, 10)

# Plot with 'viridis' colormap
plt.imshow(data, cmap='viridis')
plt.colorbar()
plt.show()
2. Inferno
Type: Perceptually Uniform
Range: From black (low values) to yellow, red, and then white (high values)
Purpose: Like viridis, inferno is a perceptually uniform colormap, but it is designed to emphasize the "hot" end of the spectrum. It’s especially useful for data where the high end needs to stand out more (e.g., heatmaps, temperatures, or intensity maps).
Visual Characteristics:
Starts from black, transitions through dark red and orange, then brightens to yellow and finally white.
High contrast, with the high-end values represented by bright colors.
Suitable for high-intensity data or highlighting extremes, such as in heatmaps or scientific imagery.
Example: Using inferno in Matplotlib:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = np.random.rand(10, 10)

# Plot with 'inferno' colormap
plt.imshow(data, cmap='inferno')
plt.colorbar()
plt.show()
3. Plasma
Type: Perceptually Uniform
Range: From dark purple (low values) to bright yellow (high values)
Purpose: Plasma is a high-contrast colormap designed to be visually attractive and easily interpretable. It is another perceptually uniform colormap that emphasizes vibrant, high-contrast colors. Plasma is often used in scientific data visualizations for better readability.
Visual Characteristics:
Starts with dark purple, transitions to pink, orange, and finally bright yellow.
It offers a high-contrast range that’s both visually distinct and aesthetically pleasing.
Plasma is often used when you want the plot to stand out or have a more dynamic feel compared to viridis.
Example: Using plasma in Matplotlib:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = np.random.rand(10, 10)

# Plot with 'plasma' colormap
plt.imshow(data, cmap='plasma')
plt.colorbar()
plt.show()
4. Cividis
Type: Perceptually Uniform
Range: From dark blue (low values) to bright yellow (high values)
Purpose: Cividis is another perceptually uniform colormap designed specifically for people with color vision deficiencies, particularly deuteranopia and protanopia (types of red-green color blindness). It provides a clearer distinction of values without relying on red or green hues.
Visual Characteristics:
Starts with dark blue, transitioning to a greenish color and ending in yellow.
Ideal for people with color vision deficiencies, making the colormap accessible to a wider audience.
Useful for ensuring your plot is readable by individuals who might have trouble distinguishing colors like red and green.
Example: Using cividis in Matplotlib:
import matplotlib.pyplot as plt
import numpy as np

# Sample data
data = np.random.rand(10, 10)

# Plot with 'cividis' colormap
plt.imshow(data, cmap='cividis')
plt.colorbar()
plt.show()
Summary of Key Colormap Types:
Viridis:

Type: Perceptually uniform.
Best for: Continuous data, readable in grayscale, colorblind-friendly.
Color Range: Dark purple → Yellow.
Inferno:

Type: Perceptually uniform.
Best for: High-intensity data, heatmaps, emphasizing high values.
Color Range: Black → White (with reds, oranges, and yellows).
Plasma:

Type: Perceptually uniform.
Best for: High-contrast, dynamic visualizations, emphasizing vivid colors.
Color Range: Dark purple → Yellow.
Cividis:

Type: Perceptually uniform.
Best for: Color vision deficiencies, ensuring accessibility for colorblind individuals.
Color Range: Dark blue → Yellow.
**Choosing the Right

You said:
Just list 
ChatGPT said:
ChatGPT
Here is a list of the colormaps and their types:

Perceptually Uniform Colormaps:
Viridis – Dark purple to yellow
Inferno – Black to white (through red, orange, yellow)
Plasma – Dark purple to yellow
Cividis – Dark blue to yellow
Other Colormap Types:
Sequential Colormaps:

Blues
Purples
Oranges
Greens
YlGnBu
Diverging Colormaps:

RdBu
PiYG
BrBG
Spectral
Cyclic Colormaps:

twilight
hsv
Miscellaneous:

cubehelix
coolwarm (Diverging)
Set1, Set2, Set3 (Categorical)


#for all yaers scatter plot wil value without box
# Calculate min and max values for Event Count and Total Net Loss
min_event_count = aggregated_data['Event_Count'].min()
max_event_count = aggregated_data['Event_Count'].max()
min_net_loss = aggregated_data['Total_Net_Loss'].min()
max_net_loss = aggregated_data['Total_Net_Loss'].max()

# Scatter plot with manually set y-axis limits
fig, ax1 = plt.subplots(figsize=(12, 8))

# Scatter plot for Event Count
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Event_Count",
    ax=ax1,
    palette="Set2",
    s=150,  # Size of scatter points
    edgecolor='black',  # Adding a border to make points stand out
    label='Event Count'
)
ax1.set_xlabel("Business Line", fontsize=14)
ax1.set_ylabel("Event Count", fontsize=14)
ax1.tick_params(axis='y')
ax1.set_xticklabels(aggregated_data["Business Line"], rotation=45, ha="right")

# Manually set y-axis limits for Event Count (based on min and max values)
ax1.set_ylim(min_event_count - 100, max_event_count + 100)

# Create a second y-axis for Total Net Loss
ax2 = ax1.twinx()
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Total_Net_Loss",
    ax=ax2,
    color='darkorange',
    s=150,  # Size of scatter points
    edgecolor='black',  # Border to make the points visible
    label='Total Net Loss'
)
ax2.set_ylabel("Total Net Loss", fontsize=14)
ax2.tick_params(axis='y')

# Manually set y-axis limits for Total Net Loss (based on min and max values)
ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

# Add values on each point for Event Count
for i, row in aggregated_data.iterrows():
    ax1.text(
        x=row["Business Line"], 
        y=row["Event_Count"], 
        s=str(int(row["Event_Count"])), 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10
    )

# Add values on each point for Total Net Loss
for i, row in aggregated_data.iterrows():
    ax2.text(
        x=row["Business Line"], 
        y=row["Total_Net_Loss"], 
        s=f"{int(row['Total_Net_Loss']):,}", 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10
    )

# Title and layout adjustments
plt.title("Total Event Count and Total Net Loss by Business Line (4 Years)", fontsize=16, fontweight="bold")
plt.tight_layout()

# Add legends
ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

plt.show()
#################################33 with box above the point +20
# Scatter plot with manually set y-axis limits and label boxes
fig, ax1 = plt.subplots(figsize=(12, 8))

# Scatter plot for Event Count
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Event_Count",
    ax=ax1,
    palette="Set2",
    s=150,  # Size of scatter points
    edgecolor='black',  # Adding a border to make points stand out
    label='Event Count'
)
ax1.set_xlabel("Business Line", fontsize=14)
ax1.set_ylabel("Event Count", fontsize=14)
ax1.tick_params(axis='y')
ax1.set_xticklabels(aggregated_data["Business Line"], rotation=45, ha="right")

# Manually set y-axis limits for Event Count (based on min and max values)
ax1.set_ylim(min_event_count - 100, max_event_count + 100)

# Create a second y-axis for Total Net Loss
ax2 = ax1.twinx()
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Total_Net_Loss",
    ax=ax2,
    color='darkorange',
    s=150,  # Size of scatter points
    edgecolor='black',  # Border to make the points visible
    label='Total Net Loss'
)
ax2.set_ylabel("Total Net Loss", fontsize=14)
ax2.tick_params(axis='y')

# Manually set y-axis limits for Total Net Loss (based on min and max values)
ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

# Add values on each point for Event Count inside a box (shifted upwards slightly)
for i, row in aggregated_data.iterrows():
    ax1.text(
        x=row["Business Line"], 
        y=row["Event_Count"] + 20,  # Shift the label 20 units above the point
        s=str(int(row["Event_Count"])), 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10,
        bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3')
    )

# Add values on each point for Total Net Loss inside a box (shifted upwards slightly)
for i, row in aggregated_data.iterrows():
    ax2.text(
        x=row["Business Line"], 
        y=row["Total_Net_Loss"] + 200,  # Shift the label 200 units above the point
        s=f"{int(row['Total_Net_Loss']):,}", 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10,
        bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3')
    )

# Title and layout adjustments
plt.title("Total Event Count and Total Net Loss by Business Line (4 Years)", fontsize=16, fontweight="bold")
plt.tight_layout()

# Add legends
ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

plt.show()

##############33 on the points
# Scatter plot with manually set y-axis limits and label boxes
fig, ax1 = plt.subplots(figsize=(12, 8))

# Scatter plot for Event Count
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Event_Count",
    ax=ax1,
    palette="Set2",
    s=150,  # Size of scatter points
    edgecolor='black',  # Adding a border to make points stand out
    label='Event Count'
)
ax1.set_xlabel("Business Line", fontsize=14)
ax1.set_ylabel("Event Count", fontsize=14)
ax1.tick_params(axis='y')
ax1.set_xticklabels(aggregated_data["Business Line"], rotation=45, ha="right")

# Manually set y-axis limits for Event Count (based on min and max values)
ax1.set_ylim(min_event_count - 100, max_event_count + 100)

# Create a second y-axis for Total Net Loss
ax2 = ax1.twinx()
sns.scatterplot(
    data=aggregated_data,
    x="Business Line",
    y="Total_Net_Loss",
    ax=ax2,
    color='darkorange',
    s=150,  # Size of scatter points
    edgecolor='black',  # Border to make the points visible
    label='Total Net Loss'
)
ax2.set_ylabel("Total Net Loss", fontsize=14)
ax2.tick_params(axis='y')

# Manually set y-axis limits for Total Net Loss (based on min and max values)
ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

# Add values on each point for Event Count inside a box
for i, row in aggregated_data.iterrows():
    ax1.text(
        x=row["Business Line"], 
        y=row["Event_Count"], 
        s=str(int(row["Event_Count"])), 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10,
        bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3')
    )

# Add values on each point for Total Net Loss inside a box
for i, row in aggregated_data.iterrows():
    ax2.text(
        x=row["Business Line"], 
        y=row["Total_Net_Loss"], 
        s=f"{int(row['Total_Net_Loss']):,}", 
        color='black',  # Text color for visibility
        ha='center', 
        va='bottom', 
        fontsize=10,
        bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3')
    )

# Title and layout adjustments
plt.title("Total Event Count and Total Net Loss by Business Line (4 Years)", fontsize=16, fontweight="bold")
plt.tight_layout()

# Add legends
ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

plt.show()





######3



#sacttered plot values with
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Group by Business Line and Year, and calculate total Event Count and Net Loss
yearly_summary = df.groupby(["Business Line", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Business Line", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add values on each point for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Business Line"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add values on each point for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Business Line"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Business Line ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3832216077.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Group by Business Line and Year, and calculate total Event Count and Net Loss
yearly_summary = df.groupby(["Business Line", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Business Line", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Business Line ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:82: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\3987419125.py:95: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

#o modify the plot for Event Type instead of Business Line, you can make the following adjustments in the code:
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Group by Event Type and Year, and calculate total Event Count and Net Loss
yearly_summary = df.groupby(["Event Type", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Event Type", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Event Type ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1632179443.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

#with label
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Group by Event Type and Year, and calculate total Event Count and Net Loss
yearly_summary = df.groupby(["Event Type", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Event Type", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add labels for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Event Type"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add labels for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Event Type"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Event Type ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:83: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\4177120501.py:96: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

#only two category
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Filter for two specific event types
filtered_event_types = ["Fraud", "Cyber Attack"]  # Specify the event types you are interested in
filtered_df = df[df['Event Type'].isin(filtered_event_types)]

# Group by Event Type and Year, and calculate total Event Count and Net Loss
yearly_summary = filtered_df.groupby(["Event Type", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Event Type", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add labels for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Event Type"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Event Type",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add labels for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Event Type"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Event Type ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\2776808033.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Event Type"], rotation=45, ha="right")

#two business line
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (either drop or take absolute value)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Filter for two specific business lines
filtered_business_lines = ["Retail", "Investment Banking"]  # Specify the business lines you are interested in
filtered_df = df[df['Business Line'].isin(filtered_business_lines)]

# Group by Business Line and Year, and calculate total Event Count and Net Loss
yearly_summary = filtered_df.groupby(["Business Line", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Business Line", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add labels for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Business Line"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add labels for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Business Line"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Business Line ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:87: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:100: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:87: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:100: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:87: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:100: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:87: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:100: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:87: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1616247807.py:100: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (only positive values or 0)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values for Net Loss

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Filter for two specific business lines
filtered_business_lines = ["Retail", "Investment Banking"]  # Specify the business lines you are interested in
filtered_df = df[df['Business Line'].isin(filtered_business_lines)]

# Group by Business Line and Year, and calculate total Event Count and Net Loss
yearly_summary = filtered_df.groupby(["Business Line", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Business Line", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

    # Set y-axis limits for Event Count (same for all years)
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add labels for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Business Line"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set y-axis limits for Total Net Loss (same for all years)
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add labels for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Business Line"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Business Line ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1053562064.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 10000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Handle negative Net Loss values (only positive values or 0)
df['Net Loss Amount'] = df['Net Loss Amount'].apply(lambda x: max(x, 0))  # Keeping only positive values for Net Loss

# Extract Year from the Date
df['Year'] = df['Date'].dt.year

# Filter for two specific business lines
filtered_business_lines = ["Retail", "Investment Banking"]  # Specify the business lines you are interested in
filtered_df = df[df['Business Line'].isin(filtered_business_lines)]

# Group by Business Line and Year, and calculate total Event Count and Net Loss
yearly_summary = filtered_df.groupby(["Business Line", "Year"]).agg(
    Total_Net_Loss=("Net Loss Amount", "sum"),
    Event_Count=("Unique Event ID", "count")
).reset_index()

# Calculate global y-axis limits across all years for both Event Count and Total Net Loss
max_event_count = yearly_summary['Event_Count'].max()
min_event_count = yearly_summary['Event_Count'].min()
max_net_loss = yearly_summary['Total_Net_Loss'].max()
min_net_loss = yearly_summary['Total_Net_Loss'].min()

# Generate a plot for each year
years = yearly_summary['Year'].unique()

for year in years:
    # Filter data for the specific year
    year_data = yearly_summary[yearly_summary['Year'] == year]
    
    # Create dual-axis plot for Event Count and Total Net Loss
    fig, ax1 = plt.subplots(figsize=(12, 8))

    # Color palette for scatter plot (Event Count)
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Event_Count",
        ax=ax1,
        palette="Set2",  # More colorful palette (lighter tones)
        s=150,  # Size of scatter points
        edgecolor='black',  # Adding a border to make points stand out
        label='Event Count'
    )
    ax1.set_xlabel("Business Line", fontsize=14)
    ax1.set_ylabel("Event Count", fontsize=14)
    ax1.tick_params(axis='y')
    ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

    # Set consistent y-axis limits for Event Count
    ax1.set_ylim(min_event_count - 100, max_event_count + 100)

    # Add labels for Event Count
    for i, row in year_data.iterrows():
        ax1.text(
            x=row["Business Line"], 
            y=row["Event_Count"], 
            s=str(int(row["Event_Count"])), 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Create the second y-axis for Total Net Loss
    ax2 = ax1.twinx()
    sns.scatterplot(
        data=year_data,
        x="Business Line",
        y="Total_Net_Loss",
        ax=ax2,
        color='darkorange',  # Dark orange color for better contrast
        s=150,  # Size of scatter points
        edgecolor='black',  # Border to make the points visible
        label='Total Net Loss'
    )
    ax2.set_ylabel("Total Net Loss", fontsize=14)
    ax2.tick_params(axis='y')

    # Set consistent y-axis limits for Total Net Loss
    ax2.set_ylim(min_net_loss - 1000, max_net_loss + 1000)

    # Add labels for Total Net Loss
    for i, row in year_data.iterrows():
        ax2.text(
            x=row["Business Line"], 
            y=row["Total_Net_Loss"], 
            s=f"{int(row['Total_Net_Loss']):,}", 
            color='black',  # Text color for visibility
            ha='center', 
            va='bottom', 
            fontsize=10
        )

    # Title and layout adjustments
    plt.title(f"Event Count and Total Net Loss by Business Line ({year})", fontsize=16, fontweight="bold")
    plt.tight_layout()

    # Background color for dark theme
    plt.gcf().set_facecolor('#f4f4f4')  # Light background to contrast dark points

    # Add legends for both axes on the right side of the plot
    ax1.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 1), frameon=False, title_fontsize=12, labelspacing=1.5)
    ax2.legend(loc='upper left', fontsize=10, title="Metrics", bbox_to_anchor=(1.05, 0.85), frameon=False, title_fontsize=12, labelspacing=1.5)

    plt.show()
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:86: UserWarning: Ignoring `palette` because no `hue` variable has been assigned.
  sns.scatterplot(
C:\Users\Himanshu Singh\AppData\Local\Temp\ipykernel_25700\1481823114.py:99: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.
  ax1.set_xticklabels(year_data["Business Line"], rotation=45, ha="right")

 
################################ donut chart eventy type foe each month 4 ysera
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 1000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Add Year and Month columns
df['Year'] = df['Date'].dt.year

# Filter negative Net Loss Amount values
df = df[df['Net Loss Amount'] > 0]

# Group data by Business Line, Year, and Event Type
grouped = df.groupby(['Business Line', 'Year', 'Event Type']).agg({
    'Unique Event ID': 'count',  # Event Count
    'Net Loss Amount': 'sum'    # Net Loss Amount
}).reset_index()
grouped.rename(columns={'Unique Event ID': 'Event Count'}, inplace=True)

# Fixed color mapping for each event type (manually set)
event_type_colors = {
    "Fraud": "skyblue", 
    "System Failure": "lightgreen", 
    "Theft": "lightcoral", 
    "Compliance": "lightyellow",
    "Natural Disaster": "lightpink", 
    "Cyber Attack": "lightgrey", 
    "Market Risk": "lightsalmon",
    "Operational Error": "lightseagreen", 
    "Vendor Risk": "lightskyblue", 
    "Regulatory Violation": "lightsteelblue"
}

# Iterate through each business line and generate charts
business_lines = grouped['Business Line'].unique()
for business_line in business_lines:
    business_line_data = grouped[grouped['Business Line'] == business_line]
    
    # Iterate through each year
    years = business_line_data['Year'].unique()
    for year in years:
        year_data = business_line_data[business_line_data['Year'] == year]

        # Prepare data for charts
        labels = year_data['Event Type']
        sizes_event = year_data['Event Count']
        sizes_loss = year_data['Net Loss Amount']

        if len(labels) == 0:
            continue  # Skip empty data

        # Create subplots for Event Count and Net Loss Amount
        fig, axes = plt.subplots(1, 2, figsize=(14, 7))

        # Prepare legend labels with percentages for Event Count
        total_event = sizes_event.sum()
        legend_event = [
            f"{label}: {value / total_event:.1%}"
            for label, value in zip(labels, sizes_event)
        ]

        # Donut chart for Event Count with fixed colors based on Event Type
        wedges_event, texts_event, autotexts_event = axes[0].pie(
            sizes_event, labels=None, autopct=lambda pct: f"{pct:.1f}%", 
            startangle=90, pctdistance=0.85, textprops=dict(color="w"),
            colors=[event_type_colors[event] for event in labels]  # Use color mapping based on Event Type
        )
        center_circle_event = plt.Circle((0, 0), 0.70, fc='white')
        axes[0].add_artist(center_circle_event)
        axes[0].set_title(f"Event Count Distribution\n{business_line} - {year}", fontsize=12, fontweight='bold')

        # Add legend for Event Count
        axes[0].legend(wedges_event, legend_event, title="Event Types (%)", loc="best", fontsize=10)

        # Prepare legend labels with percentages for Net Loss Amount
        total_loss = sizes_loss.sum()
        legend_loss = [
            f"{label}: {value / total_loss:.1%}"
            for label, value in zip(labels, sizes_loss)
        ]

        # Donut chart for Net Loss Amount with fixed colors based on Event Type
        wedges_loss, texts_loss, autotexts_loss = axes[1].pie(
            sizes_loss, labels=None, autopct=lambda pct: f"{pct:.1f}%", 
            startangle=90, pctdistance=0.85, textprops=dict(color="w"),
            colors=[event_type_colors[event] for event in labels]  # Use color mapping based on Event Type
        )
        center_circle_loss = plt.Circle((0, 0), 0.70, fc='white')
        axes[1].add_artist(center_circle_loss)
        axes[1].set_title(f"Net Loss Amount Distribution\n{business_line} - {year}", fontsize=12, fontweight='bold')

        # Add legend for Net Loss Amount
        axes[1].legend(wedges_loss, legend_loss, title="Event Types (%)", loc="best", fontsize=10)

        # Adjust layout and display
        plt.tight_layout()
        plt.show()

########33 pie chart
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 1000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Add Year and Month columns
df['Year'] = df['Date'].dt.year

# Filter negative Net Loss Amount values
df = df[df['Net Loss Amount'] > 0]

# Group data by Business Line, Year, and Event Type
grouped = df.groupby(['Business Line', 'Year', 'Event Type']).agg({
    'Unique Event ID': 'count',  # Event Count
    'Net Loss Amount': 'sum'    # Net Loss Amount
}).reset_index()
grouped.rename(columns={'Unique Event ID': 'Event Count'}, inplace=True)

# Fixed color mapping for each event type (manually set)
event_type_colors = {
    "Fraud": "skyblue", 
    "System Failure": "lightgreen", 
    "Theft": "lightcoral", 
    "Compliance": "lightyellow",
    "Natural Disaster": "lightpink", 
    "Cyber Attack": "lightgrey", 
    "Market Risk": "lightsalmon",
    "Operational Error": "lightseagreen", 
    "Vendor Risk": "lightskyblue", 
    "Regulatory Violation": "lightsteelblue"
}

# Iterate through each business line and generate charts
business_lines = grouped['Business Line'].unique()
for business_line in business_lines:
    business_line_data = grouped[grouped['Business Line'] == business_line]
    
    # Iterate through each year
    years = business_line_data['Year'].unique()
    for year in years:
        year_data = business_line_data[business_line_data['Year'] == year]

        # Prepare data for charts
        labels = year_data['Event Type']
        sizes_event = year_data['Event Count']
        sizes_loss = year_data['Net Loss Amount']

        if len(labels) == 0:
            continue  # Skip empty data

        # Create subplots for Event Count and Net Loss Amount
        fig, axes = plt.subplots(1, 2, figsize=(14, 7))

        # Prepare legend labels with percentages for Event Count
        total_event = sizes_event.sum()
        legend_event = [
            f"{label}: {value / total_event:.1%}"
            for label, value in zip(labels, sizes_event)
        ]

        # Pie chart for Event Count with fixed colors based on Event Type
        axes[0].pie(
            sizes_event, labels=labels, autopct='%1.1f%%', 
            startangle=90, colors=[event_type_colors[event] for event in labels],
            textprops=dict(color="w")
        )
        axes[0].set_title(f"Event Count Distribution\n{business_line} - {year}", fontsize=12, fontweight='bold')

        # Add legend for Event Count
        axes[0].legend(legend_event, title="Event Types (%)", loc="best", fontsize=10)

        # Prepare legend labels with percentages for Net Loss Amount
        total_loss = sizes_loss.sum()
        legend_loss = [
            f"{label}: {value / total_loss:.1%}"
            for label, value in zip(labels, sizes_loss)
        ]

        # Pie chart for Net Loss Amount with fixed colors based on Event Type
        axes[1].pie(
            sizes_loss, labels=labels, autopct='%1.1f%%', 
            startangle=90, colors=[event_type_colors[event] for event in labels],
            textprops=dict(color="w")
        )
        axes[1].set_title(f"Net Loss Amount Distribution\n{business_line} - {year}", fontsize=12, fontweight='bold')

        # Add legend for Net Loss Amount
        axes[1].legend(legend_loss, title="Event Types (%)", loc="best", fontsize=10)

        # Adjust layout and display
        plt.tight_layout()
        plt.show()
###############pie chart for all business line  with legend percent
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 1000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Add Year and Month columns
df['Year'] = df['Date'].dt.year

# Filter negative Net Loss Amount values
df = df[df['Net Loss Amount'] > 0]

# Group data by Business Line, Event Type, and aggregate Event Count and Net Loss Amount
grouped = df.groupby(['Business Line', 'Event Type']).agg({
    'Unique Event ID': 'count',  # Event Count
    'Net Loss Amount': 'sum'    # Net Loss Amount
}).reset_index()
grouped.rename(columns={'Unique Event ID': 'Event Count'}, inplace=True)

# Fixed color mapping for each event type (manually set)
event_type_colors = {
    "Fraud": "skyblue", 
    "System Failure": "lightgreen", 
    "Theft": "lightcoral", 
    "Compliance": "lightyellow",
    "Natural Disaster": "lightpink", 
    "Cyber Attack": "lightgrey", 
    "Market Risk": "lightsalmon",
    "Operational Error": "lightseagreen", 
    "Vendor Risk": "lightskyblue", 
    "Regulatory Violation": "lightsteelblue"
}

# Iterate through each business line and generate pie charts for Event Count and Net Loss Amount
business_lines = grouped['Business Line'].unique()
for business_line in business_lines:
    business_line_data = grouped[grouped['Business Line'] == business_line]

    # Prepare data for pie charts
    labels = business_line_data['Event Type']
    sizes_event = business_line_data['Event Count']
    sizes_loss = business_line_data['Net Loss Amount']

    # Pie chart for Event Count with fixed colors based on Event Type
    fig, axes = plt.subplots(1, 2, figsize=(14, 7))

    # Pie chart for Event Count
    wedges_event, texts_event, autotexts_event = axes[0].pie(
        sizes_event, labels=labels, autopct='%1.1f%%', 
        startangle=90, colors=[event_type_colors[event] for event in labels],
        textprops=dict(color="w")
    )
    axes[0].set_title(f"Event Count Distribution\n{business_line}", fontsize=12, fontweight='bold')

    # Pie chart for Net Loss Amount with fixed colors based on Event Type
    wedges_loss, texts_loss, autotexts_loss = axes[1].pie(
        sizes_loss, labels=labels, autopct='%1.1f%%', 
        startangle=90, colors=[event_type_colors[event] for event in labels],
        textprops=dict(color="w")
    )
    axes[1].set_title(f"Net Loss Amount Distribution\n{business_line}", fontsize=12, fontweight='bold')

    # Add legends with percentages for both pie charts
    axes[0].legend(wedges_event, [f"{label}: {size/total_event:.1%}" for label, size in zip(labels, sizes_event)], title="Event Types (%)", loc="best", fontsize=10)
    axes[1].legend(wedges_loss, [f"{label}: {size/total_loss:.1%}" for label, size in zip(labels, sizes_loss)], title="Event Types (%)", loc="best", fontsize=10)

    # Adjust layout and display
    plt.tight_layout()
    plt.show()

############ #percent and value in legen
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 1000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Add Year and Month columns
df['Year'] = df['Date'].dt.year

# Filter negative Net Loss Amount values
df = df[df['Net Loss Amount'] > 0]

# Group data by Business Line, Event Type, and aggregate Event Count and Net Loss Amount
grouped = df.groupby(['Business Line', 'Event Type']).agg({
    'Unique Event ID': 'count',  # Event Count
    'Net Loss Amount': 'sum'    # Net Loss Amount
}).reset_index()
grouped.rename(columns={'Unique Event ID': 'Event Count'}, inplace=True)

# Fixed color mapping for each event type (manually set)
event_type_colors = {
    "Fraud": "skyblue", 
    "System Failure": "lightgreen", 
    "Theft": "lightcoral", 
    "Compliance": "lightyellow",
    "Natural Disaster": "lightpink", 
    "Cyber Attack": "lightgrey", 
    "Market Risk": "lightsalmon",
    "Operational Error": "lightseagreen", 
    "Vendor Risk": "lightskyblue", 
    "Regulatory Violation": "lightsteelblue"
}

# Iterate through each business line and generate pie charts for Event Count and Net Loss Amount
business_lines = grouped['Business Line'].unique()
for business_line in business_lines:
    business_line_data = grouped[grouped['Business Line'] == business_line]

    # Prepare data for pie charts
    labels = business_line_data['Event Type']
    sizes_event = business_line_data['Event Count']
    sizes_loss = business_line_data['Net Loss Amount']

    # Calculate total event count and total net loss amount for percentage calculation
    total_event = sizes_event.sum()
    total_loss = sizes_loss.sum()

    # Pie chart for Event Count with fixed colors based on Event Type
    fig, axes = plt.subplots(1, 2, figsize=(14, 7))

    # Pie chart for Event Count
    wedges_event, texts_event, autotexts_event = axes[0].pie(
        sizes_event, labels=labels, autopct='%1.1f%%', 
        startangle=90, colors=[event_type_colors[event] for event in labels],
        textprops=dict(color="w")
    )
    axes[0].set_title(f"Event Count Distribution\n{business_line}", fontsize=12, fontweight='bold')

    # Prepare legend with both value and percentage
    legend_event = [
        f"{label}: {size} events ({size/total_event:.1%})"
        for label, size in zip(labels, sizes_event)
    ]
    axes[0].legend(wedges_event, legend_event, title="Event Types", loc="best", fontsize=10)

    # Pie chart for Net Loss Amount with fixed colors based on Event Type
    wedges_loss, texts_loss, autotexts_loss = axes[1].pie(
        sizes_loss, labels=labels, autopct='%1.1f%%', 
        startangle=90, colors=[event_type_colors[event] for event in labels],
        textprops=dict(color="w")
    )
    axes[1].set_title(f"Net Loss Amount Distribution\n{business_line}", fontsize=12, fontweight='bold')

    # Prepare legend with both value and percentage
    legend_loss = [
        f"{label}: ${size:.2f} ({size/total_loss:.1%})"
        for label, size in zip(labels, sizes_loss)
    ]
    axes[1].legend(wedges_loss, legend_loss, title="Event Types", loc="best", fontsize=10)

    # Adjust layout and display
    plt.tight_layout()
    plt.show()
###### for event typrs perce and valeu in legedn
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Function to generate random dates
def random_dates(start, end, n=10):
    return [start + timedelta(days=np.random.randint(0, (end - start).days)) for _ in range(n)]

# Parameters
num_records = 1000
start_date = datetime.now() - timedelta(days=4*365)
end_date = datetime.now()

# Expanded categories
business_lines = [
    "Retail", "Corporate Banking", "Investment Banking", "Insurance",
    "Wealth Management", "Asset Management", "Private Banking",
    "Credit Card Services", "Mortgage Lending", "Financial Advisory"
]

event_types = [
    "Fraud", "System Failure", "Theft", "Compliance", "Natural Disaster",
    "Cyber Attack", "Market Risk", "Operational Error", "Vendor Risk", "Regulatory Violation"
]

# Generate data
data = {
    "Date": random_dates(start_date, end_date, num_records),
    "Unique Event ID": [f"EID{str(i).zfill(5)}" for i in range(num_records)],
    "Event Type": np.random.choice(event_types, num_records),
    "Business Line": np.random.choice(business_lines, num_records),
    "Event Description": np.random.choice(
        [
            "Unauthorized transaction", "Server downtime", "Lost assets", 
            "Regulatory fines", "Data breach", "Network failure", 
            "Inadequate compliance", "Financial misstatement", 
            "Supplier issues", "Internal fraud"
        ],
        num_records
    ),
    "Net Loss Amount": np.random.choice(
        [np.random.uniform(-10000, 0) for _ in range(num_records // 2)] + 
        [np.random.uniform(0, 10000) for _ in range(num_records // 2)],
        num_records
    )
}

# Create DataFrame
df = pd.DataFrame(data)

# Add Year and Month columns
df['Year'] = df['Date'].dt.year

# Filter negative Net Loss Amount values
df = df[df['Net Loss Amount'] > 0]

# Group data by Event Type and aggregate Event Count and Net Loss Amount
grouped = df.groupby(['Event Type']).agg({
    'Unique Event ID': 'count',  # Event Count
    'Net Loss Amount': 'sum'    # Net Loss Amount
}).reset_index()
grouped.rename(columns={'Unique Event ID': 'Event Count'}, inplace=True)

# Fixed color mapping for each event type (manually set)
event_type_colors = {
    "Fraud": "skyblue", 
    "System Failure": "lightgreen", 
    "Theft": "lightcoral", 
    "Compliance": "lightyellow",
    "Natural Disaster": "lightpink", 
    "Cyber Attack": "lightgrey", 
    "Market Risk": "lightsalmon",
    "Operational Error": "lightseagreen", 
    "Vendor Risk": "lightskyblue", 
    "Regulatory Violation": "lightsteelblue"
}

# Prepare data for pie charts
labels = grouped['Event Type']
sizes_event = grouped['Event Count']
sizes_loss = grouped['Net Loss Amount']

# Calculate total event count and total net loss amount for percentage calculation
total_event = sizes_event.sum()
total_loss = sizes_loss.sum()

# Create pie chart for Event Count with fixed colors
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

# Pie chart for Event Count
wedges_event, texts_event, autotexts_event = axes[0].pie(
    sizes_event, labels=labels, autopct='%1.1f%%', 
    startangle=90, colors=[event_type_colors[event] for event in labels],
    textprops=dict(color="w")
)
axes[0].set_title(f"Event Count Distribution", fontsize=12, fontweight='bold')

# Prepare legend with both value and percentage for Event Count
legend_event = [
    f"{label}: {size} events ({size/total_event:.1%})"
    for label, size in zip(labels, sizes_event)
]
axes[0].legend(wedges_event, legend_event, title="Event Types", loc="best", fontsize=10)

# Pie chart for Net Loss Amount with fixed colors
wedges_loss, texts_loss, autotexts_loss = axes[1].pie(
    sizes_loss, labels=labels, autopct='%1.1f%%', 
    startangle=90, colors=[event_type_colors[event] for event in labels],
    textprops=dict(color="w")
)
axes[1].set_title(f"Net Loss Amount Distribution", fontsize=12, fontweight='bold')

# Prepare legend with both value and percentage for Net Loss Amount
legend_loss = [
    f"{label}: ${size:.2f} ({size/total_loss:.1%})"
    for label, size in zip(labels, sizes_loss)
]
axes[1].legend(wedges_loss, legend_loss, title="Event Types", loc="best", fontsize=10)

# Adjust layout and display
plt.tight_layout()
plt.show()
